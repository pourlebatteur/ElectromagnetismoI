# -*- coding: utf-8 -*-
"""laplace_relaxation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bTXc26Xx8Gmyv-PHByed_JabAMDW_Dof
"""

import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm

def potencial(N, M, Vxi, Vxf, Vyi, Vyf):
    """
    Inicializa una cuadrícula 2D para valores de potencial, estableciendo los valores límite según las condiciones dadas.

    Parámetros:
    N (int): Número de puntos de la cuadrícula a lo largo del eje x.
    M (int): Número de puntos de la cuadrícula a lo largo del eje y.
    Vxi (float): Potencial en el límite izquierdo.
    Vxf (float): Potencial en el límite derecho.
    Vyi (float): Potencial en el límite inferior.
    Vyf (float): Potencial en el límite superior.

    Devuelve:
    numpy.ndarray: Array 2D de valores de potencial inicializados con condiciones de frontera.
    """
    V = np.zeros((N, M))
    V[0, :] = Vxi
    V[-1, :] = Vxf
    V[:, 0] = Vyi
    V[:, -1] = Vyf
    return V

def relajacion(V, N, M, tolerance=1e-4):
    """
    Realiza el método de relajación para resolver la ecuación de Laplace en una cuadrícula 2D.

    Parámetros:
    V (numpy.ndarray): Array 2D de valores iniciales de potencial, incluyendo condiciones de frontera.
    N (int): Número de puntos de la cuadrícula a lo largo del eje x.
    M (int): Número de puntos de la cuadrícula a lo largo del eje y.
    tolerance (float): El cambio máximo permitido entre iteraciones para la convergencia.

    Devuelve:
    numpy.ndarray: Array 2D de valores de potencial después de aplicar el método de relajación.
    """
    for _ in tqdm(range(int(1e4))):
        V_u = V.copy()
        V_u[1:-1, 1:-1] = 0.25 * (V[2:, 1:-1] + V[:-2, 1:-1] + V[1:-1, 2:] + V[1:-1, :-2])

        if np.abs(V_u - V).max() < tolerance:
            break

        V = V_u

    return V

def analitica(x, y, v0, a, b):
    """
    Calcula la solución analítica para el potencial 2D en un dominio rectangular.

    Parámetros:
    x (numpy.ndarray): Array de coordenadas x.
    y (numpy.ndarray): Array de coordenadas y.
    v0 (float): Factor de escala para el potencial.
    a (float): Longitud del dominio en la dirección x.
    b (float): Longitud del dominio en la dirección y.

    Devuelve:
    numpy.ndarray: Array 2D que representa la solución analítica del potencial.
    """
    X, Y = np.meshgrid(x, y)
    Va = np.zeros_like(X)

    for n in range(1, 200, 2):  # Aumentamos el número de términos de la serie para mayor precisión
        Const = (1 + np.cosh(n * np.pi * b / a)) / (np.sinh(n * np.pi * b / a))
        Va += (Const * np.sinh(n * np.pi * X / a) - np.cosh(n * np.pi * X / a)) * np.sin(n * np.pi * Y / a) / n

    return (4 * v0 / np.pi) * Va

# Parámetros
Vxi, Vxf, Vyi, Vyf = 0, 0, -1, 1
N, M, dxy = 50, 50, 0.02  # Aumentamos el número de puntos y reducimos el tamaño del paso para aumentar la definición
x = np.linspace(0, N * dxy, N)
y = np.linspace(0, M * dxy, M)

# Solución numérica
Vc = potencial(N, M, Vxi, Vxf, Vyi, Vyf)
Vc = relajacion(Vc, N, M)

# Solución analítica
Va = analitica(x, y, 1, N * dxy, M * dxy)

# Gráficas
# Gráficas de la solución computacional
fig1 = plt.figure(figsize=(15, 10))

# Gráfica 3D solución computacional
ax1 = fig1.add_subplot(221, projection='3d')
X, Y = np.meshgrid(x, y)
ax1.plot_surface(X, Y, Vc.T, cmap='viridis')
ax1.set_title('Solución computacional en 3D')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('Potencial')

# Gráfica 2D solución computacional
ax2 = fig1.add_subplot(222)
levels = np.linspace(Vc.min() - 1e-5, Vc.max() + 1e-5, 100)
contour = ax2.contourf(X, Y, Vc.T, levels=levels)
plt.colorbar(contour)
ax2.set_title('Solución computacional en 2D')
ax2.set_xlabel('x')
ax2.set_ylabel('y')

# Gráficas de la solución analítica
fig2 = plt.figure(figsize=(15, 10))

# Gráfica 3D solución analítica
ax3 = fig2.add_subplot(221, projection='3d')
ax3.plot_surface(X, Y, Va.T, cmap='viridis')
ax3.set_title('Solución analítica en 3D')
ax3.set_xlabel('x')
ax3.set_ylabel('y')
ax3.set_zlabel('Potencial')

# Gráfica 2D solución analítica
ax4 = fig2.add_subplot(222)
contour = ax4.contourf(X, Y, Va.T, levels=levels)
plt.colorbar(contour)
ax4.set_title('Solución analítica en 2D')
ax4.set_xlabel('x')
ax4.set_ylabel('y')

plt.tight_layout()
plt.show()

# Guardar las imágenes
fig1.savefig('solucion_computacional.png')
fig2.savefig('solucion_analitica.png')


# Calcular y mostrar el error
error_absoluto = np.mean(np.abs(Va - Vc))
error_cuadratico = np.mean((Va - Vc) ** 2)
print("Error absoluto promedio:", error_absoluto)
print("Error al cuadrado:", error_cuadratico)

